=== HEAP_JUMIA CTF SOLUTION ===

Challenge: heap_jumia (heap Use-After-Free exploitation)
Flag Format: DeepSec{...}

## Vulnerability Analysis

The binary has a classic Use-After-Free (UAF) vulnerability:

1. **Global Variable**: `allocated_space` is a global pointer initialized by `main` with `malloc(0x26)` (38 bytes)
2. **Initialization**: `allocated_space[30..37]` is set to "deadbeef\x00"
3. **obliterate() function**: Calls `free(allocated_space)` but does NOT null the pointer (UAF!)
4. **reserve_space() function**: 
   - Reads a size from user
   - Calls `malloc(size)` and stores result in LOCAL variable
   - Calls `scanf("%s", local_malloc_ptr)` with NO size limit (buffer overflow!)
5. **road_to_salvation() function**:
   - Checks if `strcmp(allocated_space + 30, "w3th4nds") == 0`
   - If true: calls `success()` which opens and prints `flag.txt`

## Exploitation Strategy

**UAF + Tcache Reuse Attack:**

1. Choose option 2 (Obliterate) → frees `allocated_space` (38 bytes)
   - The freed chunk goes into tcache bin for size 0x30 (48 bytes with metadata)
   - `allocated_space` still points to the freed memory (UAF)

2. Choose option 1 (Reserve space) → malloc same size
   - Input size: 38 (0x26) bytes
   - Tcache returns the SAME chunk that was just freed
   - This chunk is stored in a LOCAL variable, not the global

3. Input payload via scanf:
   - Payload: 30 bytes filler + "w3th4nds"
   - This writes to the reused chunk
   - Since `allocated_space` still points to this chunk, we overwrite `allocated_space[30]`

4. Choose option 3 (Escape/road_to_salvation)
   - The strcmp check passes: `allocated_space + 30` now contains "w3th4nds"
   - Flag is printed from flag.txt!

## Exploit Script

```python
#!/usr/bin/env python3

# Exploit sequence
input_sequence = [
    '2',  # Obliterate (free allocated_space)
    '1',  # Reserve space
    '38', # Size = 0x26 (same as original allocation)
    'A' * 30 + 'w3th4nds',  # Payload: filler + magic string
    '3'   # Road to salvation (trigger check)
]

# Send to binary
for line in input_sequence:
    print(line)
```

## Manual Exploit

```bash
printf '2\n1\n38\n%sw3th4nds\n3\n' $(python3 -c "print('A'*30)") | ./heap_jumia
```

## Key Insights

- The vulnerability combines UAF with unsafe scanf (no length check)
- Tcache (glibc 2.27+) deterministically reuses freed chunks of the same size
- The global pointer `allocated_space` is never updated after free, enabling the UAF
- We overwrite the magic bytes at offset +30 to match the hardcoded check "w3th4nds"

## Flag

The flag is obtained by running this exploit against the remote server where flag.txt contains the actual DeepSec{...} flag.

**Author**: w3th4nds (based on binary strings)
**Difficulty**: Medium (UAF + Tcache understanding required)
